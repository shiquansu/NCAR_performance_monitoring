#!/usr/bin/env python

import os
import sys
import re
import json
import ast
import subprocess
import bisect
import time
import datetime
import glob

class extractRrd(object):
    """Example class that extract rrd record into local human readable files"""
    def __init__(self,fname,Date):
        print "extractRrd object to be initialized by: RTfname,queryDate",fname,Date
        self.nodeListFile=fname+"-NodeList-all.txt"
        #self.nodeListFile=fname+"-NodeList-1.txt"
        self.RRDsListFile=fname+"-RRDsList.txt"
        self.nodeDict={}
        self.metricList=[]
        self.machine=fname
        self.queryDate=Date
        self.rrdDate=Date[6:]+'.'+Date[4:6]+'.'+Date[0:4]
        #self.fetchMethod="fetch_all_rrd"
        self.fetchMethod="xport_multi_rrd_remote"
        self.scriptName="expectScript-"+fname+"-"+self.fetchMethod
        #self.homePath="/home/xdmod/NCAR_performance_monitoring/"
        self.homePath="/glade/p/work/shiquan/NCAR_performance_monitoring/"
        #self.dataPath="/home/xdmod/data/"
        self.dataPath="/glade/p/work/shiquan/yellowstoneRRD/"
        #self.outputPcpMethod="remoteServer"
        self.outputPcpMethod="xdmodServer"
        self.dailyEntryNumber=288
        self.outputDirectory=""

        self.totalWarn=0
        self.totalFail=0
        self.nodeFail=0
        self.totalDone=0

    def readNodeDictionary(self):
        #print "fetch {ysadmin1:[node1, node2,...],ysadmin2:[node1, node2,...]}"
        f = open(self.nodeListFile, 'r')
        md={}
        md=eval(f.readline())
        for tm in md[self.machine]:
            self.nodeDict[tm]=md[self.machine][tm]

        #self.nodeDict={} 
        #self.nodeDict['ysadmin2']=['ys1705', 'ys1752'] 
        #self.nodeDict['ysadmin1']=['ys0355', 'ys0124'] 
        #self.nodeDict['ysadmin4']=['ys4143'] 
        #self.nodeDict['ysadmin5']=['ys4951', 'ys4846', 'ys5163', 'ys5162', 'ys5164', 'ys5165', 'ys5167'] 
        #self.nodeDict['ysadmin6']=['ys5815'] 
        #print self.nodeDict 

    def readMetricList(self):
        #print "fetch [metric1,metric2,...]"
        f = open(self.RRDsListFile, 'r')
        self.metricList=eval(f.readline())

        #self.metricList=[]
        #self.metricList=["cpu_intr", "mem_cached", "disk_free"]
        #print self.metricList

    def buildExpectScript(self):
        message="""#!/usr/bin/expect
set timeout 1
set ip [lindex $argv 0]
set port [lindex $argv 1]
set node_name [lindex $argv 2]
set metric [lindex $argv 3]
set query_date [lindex $argv 4]
spawn telnet $ip $port
expect "'^]'."
"""+'%s'+"""
expect eof
"""
        f = open("expectScript-yellowstone-xport_rrd_metric", 'w')
        remoteRRDCommandLine="""send -- "xport -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\' DEF:out=yellowstone/$node_name/$metric.rrd:sum:AVERAGE XPORT:out:\\'$metric\\'\\r" """
        f.write(message%remoteRRDCommandLine)
        f.close()

        f = open("expectScript-yellowstone-fetch_rrd_metric", 'w')
        remoteRRDCommandLine="""send -- "fetch yellowstone/$node_name/$metric.rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """
        f.write(message%remoteRRDCommandLine)
        f.close()

        f = open("expectScript-yellowstone-fetch_all_rrd", 'w')
        remoteRRDCommandLine=""
        for metricName in self.metricList:
            remoteRRDCommandLine+="""send -- "fetch yellowstone/$node_name/"""+metricName+""".rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """+"\n"
        f.write(message%remoteRRDCommandLine)
        f.close()

        f = open("expectScript-yellowstone-fetch_all_rrd_sync", 'w')
        remoteRRDCommandLine=""
        for metricName in self.metricList:
            remoteRRDCommandLine+="""send -- "fetch yellowstone/$node_name/"""+metricName+""".rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """+"\n"
            remoteRRDCommandLine+="expect eof"+"\n"
        f.write(message%remoteRRDCommandLine)
        f.close()


        f = open("expectScript-yellowstone-xport_multi_rrd_remote", 'w')
        remoteRRDCommandLine="""send -- "xport -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\' --json """
        msgDEF=""
        msgOUT=""
        msg1="DEF:out%s=yellowstone/$node_name/%s.rrd:sum:AVERAGE "
        msg2="XPORT:out%s:\\'%s\\' "
        icounter=10
        for metricName in self.metricList:
            msgDEF+=msg1%(icounter,metricName)
            msgOUT+=msg2%(icounter,metricName)
            icounter+=1
        remoteRRDCommandLine+=msgDEF+msgOUT
        remoteRRDCommandLine+="""\\r" """ 

        f.write(message%remoteRRDCommandLine)
        f.close()


        message1="""#!/usr/bin/expect
set timeout 1
set machine [lindex $argv 0]
set port [lindex $argv 1]
set node_name [lindex $argv 2]
set metric [lindex $argv 3]
set query_date [lindex $argv 4]
spawn telnet ganglia $port
expect "'^]'."
send -- "cd yellowstone \\r"
expect "'^]'."
"""+'%s'+"""
expect eof
"""
        f = open("expectScript-yellowstone-fetch_all_rrd_single_sever", 'w')
        remoteRRDCommandLine=""
        counter=0
        for metricName in self.metricList:
            remoteRRDCommandLine+="""send -- "fetch $node_name/"""+metricName+""".rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """+"\n"
            if counter%8 == 7:
                remoteRRDCommandLine+="expect eof"+"\n"
            counter+=1
        f.write(message1%remoteRRDCommandLine)
        f.close()

        f = open("expectScript-yellowstone-xport_multi_rrd_local", 'w')
        remoteRRDCommandLine="""send -- "xport -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\' --json """
        msgDEF=""
        msgOUT=""
        msg1="DEF:out%s=$node_name/%s.rrd:sum:AVERAGE "
        msg2="XPORT:out%s:\\'%s\\' "
        icounter=10
        for metricName in self.metricList:
            msgDEF+=msg1%(icounter,metricName)
            msgOUT+=msg2%(icounter,metricName)
            icounter+=1
        remoteRRDCommandLine+=msgDEF+msgOUT
        remoteRRDCommandLine+="""\\r" """
        f.write(message1%remoteRRDCommandLine)
        f.close()


    def checkOutputDirectory(self,queryDate,serverName,nodeName):
        metricPath=self.dataPath+queryDate
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)
        metricPath=metricPath+"/"+serverName
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)
        metricPath=metricPath+"/yellowstone"
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)
        metricPath=metricPath+"/"+nodeName
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
            ff=open(metricPath+"/.notdone.txt", 'w')
            ff.write('not done')
            ff.close()
        self.outputDirectory=metricPath
        os.chdir(self.homePath)
        #os.chdir(metricPath)

    def locateDirectoryPcp(self,nodeName):
        metricPath=self.dataPath+'pcp-logs/'
        os.chdir(metricPath)
        metricPath=metricPath+nodeName+'/'
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)

    def extractRrdData(self,serverName,nodeName,metricName):
        rrdcommand="expect "+self.homePath+"/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" "+metricName+" "+self.rrdDate
        #print rrdcommand
        rrdData=runSysCommand(rrdcommand)
        f = open(metricName+'.rrd', 'w')
        #print rrdData[7:-1] 
        for itxt in rrdData[7:-1]:
            f.write(itxt)
        f.close() 

    def extractAllRrd(self,serverName,nodeName):
        rrdcommand="expect "+self.homePath+"/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" all "+self.rrdDate
        rrdData=runSysCommand(rrdcommand)
        for ii in range(len(self.metricList)):
            metricName=rrdData[4+ii]
            metricName=metricName.split()[1].split("/")[2]
            f = open(metricName, 'w')
            offset=4+len(self.metricList)+ii*(self.dailyEntryNumber+3)
            for itxt in rrdData[offset+2:offset+2+self.dailyEntryNumber]:
                f.write(itxt)
            f.close() 

    def extractAllRrdToPcp(self,serverName,nodeName):
        rrdcommand="expect "+self.homePath+"scripts/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" all "+self.rrdDate
        rrdData=runSysCommand(rrdcommand)
        #print 'rrdcommand=',rrdcommand
        os.system('pwd')
        os.system('rm -rf tmpdir')
        os.makedirs("tmpdir")
        #os.system("mkdir tmpdir")
        #print 'after print rrdcommand\n'
        for ii in range(len(self.metricList)):
            iioffset=(ii/8*8)*(self.dailyEntryNumber+3)+ii
            metricName=rrdData[4+iioffset]
            #print "metricName with path=",metricName
            metricName=metricName.split()[1].split("/")[-1]
            #print "metricName=",metricName
            f = open('./tmpdir/'+metricName, 'w')
            iioffset=(ii/8+1)*8
            offset=4+iioffset+ii*(self.dailyEntryNumber+3)
            for itxt in rrdData[offset+2:offset+2+self.dailyEntryNumber]:
                f.write(itxt)
            f.close()
        pcpPath=self.dataPath+'pcp-logs/'+self.machine+'/'+nodeName
        #print 'pcpPath',pcpPath 
        os.system('perl '+self.homePath+'/scripts/ganglia2pcp-20160906.pl -s '+self.queryDate+' -e '+self.queryDate+' -f '+self.queryDate+'.00.00 -d '+pcpPath+' -a '+serverName+' -h '+nodeName+' '+pcpPath+'/tmpdir')
        os.system('rm -rf tmpdir')


    def xport_multi_rrd_local(self,serverName,nodeName):
        rrdcommand="expect "+self.homePath+"scripts/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" all "+self.rrdDate
        rrdData=runSysCommand(rrdcommand)
        #print 'rrdcommand=',rrdcommand
        #os.system('pwd')
        #print 'after print rrdcommand\n'
        #print "len(self.metricList), self.metricList=",len(self.metricList), self.metricList,"\n"
        #print "rrdData=",rrdData
        for ii in range(len(self.metricList)):
            metricName=rrdData[11+ii]
            #print "metricName with path=",metricName
            istart=rrdData[7].split(": ")[1]
            iioffset=(11+len(self.metricList)+3)
            offset=4+iioffset+ii*(self.dailyEntryNumber+3)
            for itxt in rrdData[iioffset:iioffset+self.dailyEntryNumber]:
                jtxt=itxt[6:-3]
                jtxt=jtxt.split(", ")[ii]
                ktxt=istart+", "+jtxt
                f.write(ktxt)
            f.close()


    def xport_multi_rrd_remote(self,serverName,nodeName):
        rrdcommand="expect "+self.homePath+"scripts/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" all "+self.rrdDate
        rrdData=runSysCommand(rrdcommand)
        #rrdData=subprocess.Popen(rrdcommand,
        #         shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
        #         stderr=subprocess.STDOUT, close_fds=True)
        #f1 = open(self.homePath+"scripts/xport_rrd.txt", 'w') 
        #for ii  in range(len(rrdData)):
        #    f1.write(rrdData[ii])
        #f1.close()
        #sanityCheckAndParse

        itime=[]
        try:
            istart=rrdData[7].split(": ")[1].split(",")[0].lstrip(' ')
            istep= rrdData[8].split(": ")[1].split(",")[0].lstrip(' ')
            #print self.queryDate, istart, istep
            #print self.queryDate[0:4], self.queryDate[4:6], self.queryDate[6:8]
            dt = datetime.datetime(int(self.queryDate[0:4]), int(self.queryDate[4:6]), int(self.queryDate[6:8]), 0, 5)
            cstart=time.mktime(dt.timetuple())
            #print "cstart,istart,istep=",cstart,int(istart),int(istart)+int(istep),"\n"
        except:
            print "can not read time, use calculated values, date, server, node=",self.queryDate,serverName,nodeName,"\n"
            dt = datetime.datetime(self.queryDate[0:3], self.queryDate[4:5], self.queryDate[6:7], 0, 0)
            istart=time.mktime(dt.timetuple())
            istep=300

        for linenum in range(self.dailyEntryNumber):
            itime.append( int(istart)+linenum*int(istep) )
        #print "itime=",itime,"\n"
        ivalue=[]
        for linenum in range(self.dailyEntryNumber):
            ivalue.append([])
            for ii in range(len(self.metricList)):
               ivalue[linenum].append('Nan')
        #print "ivalue=",ivalue
  
        offset=11+len(self.metricList)+3
        try:
            for linenum in range(self.dailyEntryNumber):
                templine=rrdData[offset+linenum]
                templine=templine.split("[ ")[1]
                templine=templine.split(" ]")[0]
                linelist=templine.split(", ") 
                for ii in range(len(self.metricList)):
                    ivalue[linenum][ii]=linelist[ii]
                    #print "ivalue[linenum][ii]=",ivalue[linenum][ii] 
                self.totalDone+=1
        except:
            print "Error: rrd data fail at: ",self.queryDate,serverName,nodeName

        #print "ivalue=",ivalue

        for ii in range(len(self.metricList)):
            metricName=rrdData[11+ii]
            metricName=metricName.split("'")[1]
            #print "metricName=",metricName
            #print self.outputDirectory+"/"+metricName+".rrd"
            f = open(self.outputDirectory+"/"+metricName+".rrd", 'w')
            #print "out to: ", self.outputDirectory+"/"+metricName+".rrd"
            for linenum in range(self.dailyEntryNumber):
                f.write(str(itime[linenum])+": "+str(ivalue[linenum][ii])+"\n")
            f.close()
        #os.system("cat "+self.outputDirectory+"/"+metricName+".rrd")

    def sanityCheck(self,serverName,nodeName):
        pass

    def houseKeeping(self):
        os.chdir(self.homePath+'/scripts')
        #folderName=self.machine+'_'+self.queryDate
        #os.system('mkdir '+folderName)
        #os.system('mv rrdMetric-* ./'+folderName)
        #os.system('rm ./'+self.scriptName)
        #os.system('rm ./expect_*')
        #os.system('rm ./expectScript-*')

        #os.system('tar cvf '+self.homePath+self.queryDate+'.tar '+self.homePath+self.queryDate)
        print "totalDone, totalFail, totalWarn=", self.totalDone, self.totalFail, self.totalWarn
        print "clean up"
 
def runSysCommand(scommand):
    tmpscreenout=subprocess.Popen(scommand,
                 shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                 stderr=subprocess.STDOUT, close_fds=True)
    #tmp_array=tmpscreenout
    tmp_array=tmpscreenout.stdout.readlines()
    #print tmp_array
    return tmp_array

if __name__ == "__main__":
    if(len(sys.argv) < 3):
        print( "USAGE: nohup python %s machine yyyymmdd > screenoutputyyyymmdd.txt 2>erroryyyymmdd.txt & \n The files machine-NodeList-all.txt and machine-RRDsList.txt must exist in the same directory of %s. \n machine is the full name of the machine (yellowstone,laramie), yyymmdd is the query date, and covers the period of yyyy/mm/dd/00:00:00 to yyyy/mm/dd/23:59:00."%(sys.argv[0], sys.argv[0]) )
        sys.exit(1)

    p = extractRrd(sys.argv[1],sys.argv[2])
    p.readNodeDictionary()
    p.readMetricList()
    p.buildExpectScript()
    methodToCall = getattr(p, p.fetchMethod)
    #exit()
    for serverName in p.nodeDict.keys():
        for nodeName in p.nodeDict[serverName]:
            #p.locateDirectoryPcp(nodeName)
            p.checkOutputDirectory(p.queryDate,serverName,nodeName)

            """
            if p.fetchMethod == "fetch_single_rrd":  
                try:
                    for metricName in p.metricList:
                        #print ("try to collect rrd: %s, %s, %s, %s" % (queryDate, serverName, nodeName, metricName))
                        p.extractRrdData(serverName,nodeName,metricName)
                except:
                    print ("Cannot collect single rrd: %s, %s, %s, %s" % (queryDate, serverName, nodeName))
            if p.fetchMethod == "fetch_all_rrd":
                try:
                    #print "fetchMethod=",p.fetchMethod 
                    #p.extractAllRrd(serverName,nodeName)
                    p.extractAllRrdToPcp(serverName,nodeName)
                except:
                    print ("Cannot collect all rrd: %s, %s, %s" % (p.queryDate, serverName, nodeName))
            if p.fetchMethod == "xport_multi_rrd":
                try:
                    #print "fetchMethod=",p.fetchMethod 
                    #p.extractAllRrd(serverName,nodeName)
                    p.xportMultiRrdToPcp(serverName,nodeName)
                except:
                    print ("Cannot collect all rrd: %s, %s, %s" % (p.queryDate, serverName, nodeName))
            """
            #os.remove(".notdone.txt")
  
            attempts=0
            jobdone=0
            while attempts<3:
                try:
                   p.nodeFail=0
                   methodToCall(serverName,nodeName)
                   p.sanityCheck(serverName,nodeName)
                   if (not p.nodeFail==0):
                       p.totalWarn+=1
                   attempts = 3
                   jobdone=1
                except:
                   attempts += 1
                   time.sleep(0.1*attempts*attempts)

            if (not jobdone):
                print ("Cannot collect: %s, %s, %s, %s" % (p.queryDate, serverName, nodeName,p.fetchMethod))
                p.totalFail+=1

    p.houseKeeping()
    os.chdir(p.homePath)


