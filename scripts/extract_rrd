#!/usr/bin/env python

import os
import sys
import re
import json
import ast
import subprocess
import bisect
import time
import glob

class extractRrd(object):
    """Example class that extract rrd record into local human readable files"""
    def __init__(self,fname,Date):
        print "RTfname,queryDate",fname,Date
        self.nodeListFile="NodeList-"+fname+"all.txt"
        #self.nodeListFile="NodeList-"+fname+"1.txt"
        self.nodeDict={}
        self.metricList=[]
        self.machine=fname
        self.queryDate=Date
        self.rrdDate=Date[6:]+'.'+Date[4:6]+'.'+Date[0:4]
        #self.scriptName="expect_fetch_rrd_metric"
        self.scriptName="expect_fetch_all_rrd_metrics"
        #self.homePath="/glade/u/home/shiquan/Desktop/testExpect/"
        self.homePath="/glade/p/work/shiquan/testYSWorkSpace/"
        self.fetchMethod="fetch_all_metrics"
        self.dailyEntryNumber=288

    def readNodeDictionary(self):
        print "fetch {ysadmin1:[node1, node2,...],ysadmin2:[node1, node2,...]}"
        f = open(self.nodeListFile, 'r')
        md={}
        md=eval(f.readline())
        for tm in md[self.machine]:
            self.nodeDict[tm]=md[self.machine][tm]

        #self.nodeDict={} 
        #self.nodeDict['ysadmin2']=['ys1705', 'ys1752'] 
        #self.nodeDict['ysadmin1']=['ys0355', 'ys0124'] 

        #print self.nodeDict 

    def readMetricList(self):
        #print "fetch [metric1,metric2,...]"
        #self.metricList=["cpu_intr", "mem_cached", "disk_free"]
        #, "ib0_rcv_data", "hpm_snl_rate_usertime", "swap_free", "hpm_wallclock", "load_one", "cpu_speed", "ib0_xmit_data", "part_max_used", "bytes_out", "hpm_dbl_packed_flops", "disk_total", "hpm_dbl_scalar_flops", "proc_run", "pkts_out", "mem_free", "hpm_snl_rate_wallclock", "mem_shared", "cpu_system", "cpu_nice", "hpm_flops", "hpm_dbl_rate_usertime", "boottime", "bytes_in", "hpm_snl_packed", "pkts_in", "load_five", "cpu_aidle", "cpu_user", "hpm_dbl_rate_wallclock", "mem_buffers", "cpu_sintr", "cpu_idle", "cpu_num", "swap_total", "mem_total", "hpm_snl_scalar", "load_fifteen", "cpu_wio", "proc_total"]
        self.metricList=["cpu_intr", "mem_cached", "disk_free", "ib0_rcv_data", "hpm_snl_rate_usertime", "swap_free", "hpm_wallclock", "load_one", "cpu_speed", "ib0_xmit_data", "part_max_used", "bytes_out", "hpm_dbl_packed_flops", "disk_total", "hpm_dbl_scalar_flops", "proc_run", "pkts_out", "mem_free", "hpm_snl_rate_wallclock", "mem_shared", "cpu_system", "cpu_nice", "hpm_flops", "hpm_dbl_rate_usertime", "boottime", "bytes_in", "hpm_snl_packed", "pkts_in", "load_five", "cpu_aidle", "cpu_user", "hpm_dbl_rate_wallclock", "mem_buffers", "cpu_sintr", "cpu_idle", "cpu_num", "swap_total", "mem_total", "hpm_snl_scalar", "load_fifteen", "cpu_wio", "proc_total"]
        print self.metricList

    def buildExpectScript(self):
        message="""#!/usr/bin/expect
set timeout 1
set ip [lindex $argv 0]
set port [lindex $argv 1]
set node_name [lindex $argv 2]
set metric [lindex $argv 3]
set query_date [lindex $argv 4]
spawn telnet $ip $port
expect "'^]'."
"""+'%s'+"""
expect eof
"""
        f = open("expect_xport_rrd_metric", 'w')
        remoteRRDCommandLine="""send -- "xport -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\' DEF:out=yellowstone/$node_name/$metric.rrd:sum:AVERAGE XPORT:out:\\'$metric\\'\\r" """
        f.write(message%remoteRRDCommandLine)
        f.close()

        f = open("expect_fetch_rrd_metric", 'w')
        remoteRRDCommandLine="""send -- "fetch yellowstone/$node_name/$metric.rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """
        f.write(message%remoteRRDCommandLine)
        f.close()

        f = open("expect_fetch_all_rrd_metrics", 'w')
        remoteRRDCommandLine=""
        for metricName in self.metricList:
            remoteRRDCommandLine+="""send -- "fetch yellowstone/$node_name/"""+metricName+""".rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """+"\n"
        f.write(message%remoteRRDCommandLine)
        f.close()

        f = open("expect_fetch_all_rrd_metrics_sync", 'w')
        remoteRRDCommandLine=""
        for metricName in self.metricList:
            remoteRRDCommandLine+="""send -- "fetch yellowstone/$node_name/"""+metricName+""".rrd AVERAGE -s \\'00:00 $query_date\\' -e \\'23:59 $query_date\\'\\r" """+"\n"
            remoteRRDCommandLine+="expect eof"+"\n"
        f.write(message%remoteRRDCommandLine)
        f.close()

    def locateDirectory(self,queryDate,serverName,nodeName):
        metricPath=self.homePath+queryDate
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)
        metricPath=metricPath+"/"+serverName
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)
        metricPath=metricPath+"/yellowstone"
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
        os.chdir(metricPath)
        metricPath=metricPath+"/"+nodeName
        if not os.path.exists(metricPath):
            os.makedirs(metricPath)
            open(metricPath+"/.notdone.txt", 'w')
        os.chdir(metricPath)

    def extractRrdData(self,serverName,nodeName,metricName):
        rrdcommand="expect "+self.homePath+"/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" "+metricName+" "+self.rrdDate
        print rrdcommand
        rrdData=runSysCommand(rrdcommand)
        f = open(metricName+'.rrd', 'w')
        #print rrdData[7:-1] 
        for itxt in rrdData[7:-1]:
            f.write(itxt)
        f.close() 

    def extractAllRrd(self,serverName,nodeName):
        #print "line118\n"
        rrdcommand="expect "+self.homePath+"/"+self.scriptName+" "+serverName+" 13900 "+nodeName+" all "+self.rrdDate
        rrdData=runSysCommand(rrdcommand)
        for ii in range(len(self.metricList)):
            #print "ii=",ii,"\n"
            metricName=rrdData[4+ii]
            metricName=metricName.split()[1].split("/")[2]
            #print metricName,"\n"        
            f = open(metricName, 'w')
            offset=4+len(self.metricList)+ii*(self.dailyEntryNumber+3)
            for itxt in rrdData[offset+2:offset+2+self.dailyEntryNumber]:
                f.write(itxt)
            f.close() 

    def houseKeeping(self):
        #folderName=self.machine+'_'+self.queryDate
        #os.system('mkdir '+folderName)
        #os.system('mv rrdMetric-* ./'+folderName)
        #os.system('rm ./'+self.scriptName)

        os.system('tar cvf '+self.homePath+self.queryDate+'.tar '+self.homePath+self.queryDate)
        print "clean up"

def runSysCommand(scommand):
    tmpscreenout=subprocess.Popen(scommand,
                 shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                 stderr=subprocess.STDOUT, close_fds=True)
    #tmp_array=tmpscreenout
    tmp_array=tmpscreenout.stdout.readlines()
    #print tmp_array
    return tmp_array

if __name__ == "__main__":
    if(len(sys.argv) < 3):
        print("usage %s resourceTable(name of machine file containing json format resource table) queryDate(yyyymmdd)" % (sys.argv[0]))
        sys.exit(1)

    resourceTable=sys.argv[1]
    queryDate=sys.argv[2]

    print "start processing: "+resourceTable+" "+queryDate+"\n"

    p = extractRrd(resourceTable,queryDate)
    p.readNodeDictionary()
    p.readMetricList()
    p.buildExpectScript()
    for serverName in p.nodeDict.keys():
        for nodeName in p.nodeDict[serverName]:
            p.locateDirectory(queryDate, serverName, nodeName)
            if not os.path.isfile(".notdone.txt"):
                print ("Already done: %s, %s, %s" % (queryDate, serverName, nodeName))
                continue
            if p.fetchMethod == "fetch_single_metric":  
                for metricName in p.metricList:
                    try:
                        print ("try to collect rrd: %s, %s, %s, %s" % (queryDate, serverName, nodeName, metricName))
                        p.extractRrdData(serverName,nodeName,metricName)
                        #pass
                    except:
                        print ("Cannot collect rrd: %s, %s, %s, %s" % (queryDate, serverName, nodeName, metricName))
            if p.fetchMethod == "fetch_all_metrics":
                try:
                    #print "fetchMethod=",p.fetchMethod 
                    p.extractAllRrd(serverName,nodeName)
                except:
                    print ("Cannot collect rrd: %s, %s, %s" % (queryDate, serverName, nodeName))
            os.remove(".notdone.txt")
    os.chdir(p.homePath)
    p.houseKeeping()
